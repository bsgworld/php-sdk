<?php
/**
 * StopListApi
 * PHP version 7.4
 *
 * @category Class
 * @package  BSG\Api\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * One-API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BSG\Api\V2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BSG\Api\V2\ApiException;
use BSG\Api\V2\Configuration;
use BSG\Api\V2\HeaderSelector;
use BSG\Api\V2\ObjectSerializer;

/**
 * StopListApi Class Doc Comment
 *
 * @category Class
 * @package  BSG\Api\V2
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StopListApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'stoplistAdd' => [
            'application/json',
        ],
        'stoplistItems' => [
            'application/json',
        ],
        'stoplistRemove' => [
            'application/json',
        ],
        'stoplistSearch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation stoplistAdd
     *
     * Add contacts to stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistAddRequest $stoplist_add_request stoplist_add_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistAdd'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BSG\Api\V2\Model\StoplistAdd200Response|\BSG\Api\V2\Model\TooManyRequestsResponse
     */
    public function stoplistAdd($stoplist_add_request, string $contentType = self::contentTypes['stoplistAdd'][0])
    {
        list($response) = $this->stoplistAddWithHttpInfo($stoplist_add_request, $contentType);
        return $response;
    }

    /**
     * Operation stoplistAddWithHttpInfo
     *
     * Add contacts to stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistAddRequest $stoplist_add_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistAdd'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BSG\Api\V2\Model\StoplistAdd200Response|\BSG\Api\V2\Model\TooManyRequestsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stoplistAddWithHttpInfo($stoplist_add_request, string $contentType = self::contentTypes['stoplistAdd'][0])
    {
        $request = $this->stoplistAddRequest($stoplist_add_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\BSG\Api\V2\Model\StoplistAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BSG\Api\V2\Model\StoplistAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BSG\Api\V2\Model\StoplistAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BSG\Api\V2\Model\TooManyRequestsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BSG\Api\V2\Model\TooManyRequestsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BSG\Api\V2\Model\TooManyRequestsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\BSG\Api\V2\Model\StoplistAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSG\Api\V2\Model\StoplistAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSG\Api\V2\Model\TooManyRequestsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stoplistAddAsync
     *
     * Add contacts to stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistAddRequest $stoplist_add_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistAddAsync($stoplist_add_request, string $contentType = self::contentTypes['stoplistAdd'][0])
    {
        return $this->stoplistAddAsyncWithHttpInfo($stoplist_add_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stoplistAddAsyncWithHttpInfo
     *
     * Add contacts to stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistAddRequest $stoplist_add_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistAddAsyncWithHttpInfo($stoplist_add_request, string $contentType = self::contentTypes['stoplistAdd'][0])
    {
        $returnType = '\BSG\Api\V2\Model\StoplistAdd200Response';
        $request = $this->stoplistAddRequest($stoplist_add_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stoplistAdd'
     *
     * @param  \BSG\Api\V2\Model\StoplistAddRequest $stoplist_add_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stoplistAddRequest($stoplist_add_request, string $contentType = self::contentTypes['stoplistAdd'][0])
    {

        // verify the required parameter 'stoplist_add_request' is set
        if ($stoplist_add_request === null || (is_array($stoplist_add_request) && count($stoplist_add_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stoplist_add_request when calling stoplistAdd'
            );
        }


        $resourcePath = '/api/stoplist/attach';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($stoplist_add_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($stoplist_add_request));
            } else {
                $httpBody = $stoplist_add_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stoplistItems
     *
     * List the contacts of stop lists
     *
     * @param  int|null $page_offset page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 20)
     * @param  string|null $type Specify the type of the stop list for which we need to return the contact list. If the stop list type is not specified, the method will return data for all the stop list types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistItems'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BSG\Api\V2\Model\StoplistItems200Response
     */
    public function stoplistItems($page_offset = 0, $page_limit = 20, $type = null, string $contentType = self::contentTypes['stoplistItems'][0])
    {
        list($response) = $this->stoplistItemsWithHttpInfo($page_offset, $page_limit, $type, $contentType);
        return $response;
    }

    /**
     * Operation stoplistItemsWithHttpInfo
     *
     * List the contacts of stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 20)
     * @param  string|null $type Specify the type of the stop list for which we need to return the contact list. If the stop list type is not specified, the method will return data for all the stop list types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistItems'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BSG\Api\V2\Model\StoplistItems200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function stoplistItemsWithHttpInfo($page_offset = 0, $page_limit = 20, $type = null, string $contentType = self::contentTypes['stoplistItems'][0])
    {
        $request = $this->stoplistItemsRequest($page_offset, $page_limit, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\BSG\Api\V2\Model\StoplistItems200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BSG\Api\V2\Model\StoplistItems200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BSG\Api\V2\Model\StoplistItems200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\BSG\Api\V2\Model\StoplistItems200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSG\Api\V2\Model\StoplistItems200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stoplistItemsAsync
     *
     * List the contacts of stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 20)
     * @param  string|null $type Specify the type of the stop list for which we need to return the contact list. If the stop list type is not specified, the method will return data for all the stop list types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistItemsAsync($page_offset = 0, $page_limit = 20, $type = null, string $contentType = self::contentTypes['stoplistItems'][0])
    {
        return $this->stoplistItemsAsyncWithHttpInfo($page_offset, $page_limit, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stoplistItemsAsyncWithHttpInfo
     *
     * List the contacts of stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 20)
     * @param  string|null $type Specify the type of the stop list for which we need to return the contact list. If the stop list type is not specified, the method will return data for all the stop list types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistItemsAsyncWithHttpInfo($page_offset = 0, $page_limit = 20, $type = null, string $contentType = self::contentTypes['stoplistItems'][0])
    {
        $returnType = '\BSG\Api\V2\Model\StoplistItems200Response';
        $request = $this->stoplistItemsRequest($page_offset, $page_limit, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stoplistItems'
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 20)
     * @param  string|null $type Specify the type of the stop list for which we need to return the contact list. If the stop list type is not specified, the method will return data for all the stop list types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stoplistItemsRequest($page_offset = 0, $page_limit = 20, $type = null, string $contentType = self::contentTypes['stoplistItems'][0])
    {

        if ($page_offset !== null && $page_offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$page_offset" when calling StopListApi.stoplistItems, must be bigger than or equal to 0.');
        }
        
        if ($page_limit !== null && $page_limit > 500) {
            throw new \InvalidArgumentException('invalid value for "$page_limit" when calling StopListApi.stoplistItems, must be smaller than or equal to 500.');
        }
        if ($page_limit !== null && $page_limit < 15) {
            throw new \InvalidArgumentException('invalid value for "$page_limit" when calling StopListApi.stoplistItems, must be bigger than or equal to 15.');
        }
        


        $resourcePath = '/api/stoplist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_offset,
            'page[offset]', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_limit,
            'page[limit]', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stoplistRemove
     *
     * Remove contacts from stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistRemoveRequest $stoplist_remove_request stoplist_remove_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistRemove'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\BSG\Api\V2\Model\TooManyRequestsResponse
     */
    public function stoplistRemove($stoplist_remove_request, string $contentType = self::contentTypes['stoplistRemove'][0])
    {
        list($response) = $this->stoplistRemoveWithHttpInfo($stoplist_remove_request, $contentType);
        return $response;
    }

    /**
     * Operation stoplistRemoveWithHttpInfo
     *
     * Remove contacts from stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistRemoveRequest $stoplist_remove_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistRemove'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\BSG\Api\V2\Model\TooManyRequestsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function stoplistRemoveWithHttpInfo($stoplist_remove_request, string $contentType = self::contentTypes['stoplistRemove'][0])
    {
        $request = $this->stoplistRemoveRequest($stoplist_remove_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BSG\Api\V2\Model\TooManyRequestsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BSG\Api\V2\Model\TooManyRequestsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BSG\Api\V2\Model\TooManyRequestsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSG\Api\V2\Model\TooManyRequestsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stoplistRemoveAsync
     *
     * Remove contacts from stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistRemoveRequest $stoplist_remove_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistRemoveAsync($stoplist_remove_request, string $contentType = self::contentTypes['stoplistRemove'][0])
    {
        return $this->stoplistRemoveAsyncWithHttpInfo($stoplist_remove_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stoplistRemoveAsyncWithHttpInfo
     *
     * Remove contacts from stop list
     *
     * @param  \BSG\Api\V2\Model\StoplistRemoveRequest $stoplist_remove_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistRemoveAsyncWithHttpInfo($stoplist_remove_request, string $contentType = self::contentTypes['stoplistRemove'][0])
    {
        $returnType = 'object';
        $request = $this->stoplistRemoveRequest($stoplist_remove_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stoplistRemove'
     *
     * @param  \BSG\Api\V2\Model\StoplistRemoveRequest $stoplist_remove_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistRemove'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stoplistRemoveRequest($stoplist_remove_request, string $contentType = self::contentTypes['stoplistRemove'][0])
    {

        // verify the required parameter 'stoplist_remove_request' is set
        if ($stoplist_remove_request === null || (is_array($stoplist_remove_request) && count($stoplist_remove_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $stoplist_remove_request when calling stoplistRemove'
            );
        }


        $resourcePath = '/api/stoplist/detach';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($stoplist_remove_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($stoplist_remove_request));
            } else {
                $httpBody = $stoplist_remove_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stoplistSearch
     *
     * Search contacts in Stop lists
     *
     * @param  int|null $page_offset page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 50)
     * @param  string|null $sort Sort by conditions: id, phone (optional, default to 'id')
     * @param  \BSG\Api\V2\Model\SortWay|null $way way (optional)
     * @param  int|null $contact_group_id Find only phone numbers in stop list that included into specified contact list (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_field search_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_operator search_operator (optional)
     * @param  string|null $search_value search_value (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_fields_0_field search_fields_0_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_fields_0_operator search_fields_0_operator (optional)
     * @param  string|null $search_fields_0_value search_fields_0_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistSearch'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \BSG\Api\V2\Model\StoplistSearch200Response
     */
    public function stoplistSearch($page_offset = 0, $page_limit = 50, $sort = 'id', $way = null, $contact_group_id = null, $search_field = null, $search_operator = null, $search_value = null, $search_fields_0_field = null, $search_fields_0_operator = null, $search_fields_0_value = null, string $contentType = self::contentTypes['stoplistSearch'][0])
    {
        list($response) = $this->stoplistSearchWithHttpInfo($page_offset, $page_limit, $sort, $way, $contact_group_id, $search_field, $search_operator, $search_value, $search_fields_0_field, $search_fields_0_operator, $search_fields_0_value, $contentType);
        return $response;
    }

    /**
     * Operation stoplistSearchWithHttpInfo
     *
     * Search contacts in Stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 50)
     * @param  string|null $sort Sort by conditions: id, phone (optional, default to 'id')
     * @param  \BSG\Api\V2\Model\SortWay|null $way (optional)
     * @param  int|null $contact_group_id Find only phone numbers in stop list that included into specified contact list (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_operator (optional)
     * @param  string|null $search_value (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_fields_0_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_fields_0_operator (optional)
     * @param  string|null $search_fields_0_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistSearch'] to see the possible values for this operation
     *
     * @throws \BSG\Api\V2\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \BSG\Api\V2\Model\StoplistSearch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function stoplistSearchWithHttpInfo($page_offset = 0, $page_limit = 50, $sort = 'id', $way = null, $contact_group_id = null, $search_field = null, $search_operator = null, $search_value = null, $search_fields_0_field = null, $search_fields_0_operator = null, $search_fields_0_value = null, string $contentType = self::contentTypes['stoplistSearch'][0])
    {
        $request = $this->stoplistSearchRequest($page_offset, $page_limit, $sort, $way, $contact_group_id, $search_field, $search_operator, $search_value, $search_fields_0_field, $search_fields_0_operator, $search_fields_0_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\BSG\Api\V2\Model\StoplistSearch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\BSG\Api\V2\Model\StoplistSearch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BSG\Api\V2\Model\StoplistSearch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\BSG\Api\V2\Model\StoplistSearch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BSG\Api\V2\Model\StoplistSearch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation stoplistSearchAsync
     *
     * Search contacts in Stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 50)
     * @param  string|null $sort Sort by conditions: id, phone (optional, default to 'id')
     * @param  \BSG\Api\V2\Model\SortWay|null $way (optional)
     * @param  int|null $contact_group_id Find only phone numbers in stop list that included into specified contact list (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_operator (optional)
     * @param  string|null $search_value (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_fields_0_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_fields_0_operator (optional)
     * @param  string|null $search_fields_0_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistSearchAsync($page_offset = 0, $page_limit = 50, $sort = 'id', $way = null, $contact_group_id = null, $search_field = null, $search_operator = null, $search_value = null, $search_fields_0_field = null, $search_fields_0_operator = null, $search_fields_0_value = null, string $contentType = self::contentTypes['stoplistSearch'][0])
    {
        return $this->stoplistSearchAsyncWithHttpInfo($page_offset, $page_limit, $sort, $way, $contact_group_id, $search_field, $search_operator, $search_value, $search_fields_0_field, $search_fields_0_operator, $search_fields_0_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stoplistSearchAsyncWithHttpInfo
     *
     * Search contacts in Stop lists
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 50)
     * @param  string|null $sort Sort by conditions: id, phone (optional, default to 'id')
     * @param  \BSG\Api\V2\Model\SortWay|null $way (optional)
     * @param  int|null $contact_group_id Find only phone numbers in stop list that included into specified contact list (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_operator (optional)
     * @param  string|null $search_value (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_fields_0_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_fields_0_operator (optional)
     * @param  string|null $search_fields_0_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stoplistSearchAsyncWithHttpInfo($page_offset = 0, $page_limit = 50, $sort = 'id', $way = null, $contact_group_id = null, $search_field = null, $search_operator = null, $search_value = null, $search_fields_0_field = null, $search_fields_0_operator = null, $search_fields_0_value = null, string $contentType = self::contentTypes['stoplistSearch'][0])
    {
        $returnType = '\BSG\Api\V2\Model\StoplistSearch200Response';
        $request = $this->stoplistSearchRequest($page_offset, $page_limit, $sort, $way, $contact_group_id, $search_field, $search_operator, $search_value, $search_fields_0_field, $search_fields_0_operator, $search_fields_0_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stoplistSearch'
     *
     * @param  int|null $page_offset (optional, default to 0)
     * @param  int|null $page_limit The number of items in the response (optional, default to 50)
     * @param  string|null $sort Sort by conditions: id, phone (optional, default to 'id')
     * @param  \BSG\Api\V2\Model\SortWay|null $way (optional)
     * @param  int|null $contact_group_id Find only phone numbers in stop list that included into specified contact list (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_operator (optional)
     * @param  string|null $search_value (optional)
     * @param  \BSG\Api\V2\Model\StoplistSearchField|null $search_fields_0_field (optional)
     * @param  \BSG\Api\V2\Model\SearchOperator|null $search_fields_0_operator (optional)
     * @param  string|null $search_fields_0_value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['stoplistSearch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function stoplistSearchRequest($page_offset = 0, $page_limit = 50, $sort = 'id', $way = null, $contact_group_id = null, $search_field = null, $search_operator = null, $search_value = null, $search_fields_0_field = null, $search_fields_0_operator = null, $search_fields_0_value = null, string $contentType = self::contentTypes['stoplistSearch'][0])
    {

        if ($page_offset !== null && $page_offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$page_offset" when calling StopListApi.stoplistSearch, must be bigger than or equal to 0.');
        }
        
        if ($page_limit !== null && $page_limit > 500) {
            throw new \InvalidArgumentException('invalid value for "$page_limit" when calling StopListApi.stoplistSearch, must be smaller than or equal to 500.');
        }
        if ($page_limit !== null && $page_limit < 15) {
            throw new \InvalidArgumentException('invalid value for "$page_limit" when calling StopListApi.stoplistSearch, must be bigger than or equal to 15.');
        }
        










        $resourcePath = '/api/stoplist/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_offset,
            'page[offset]', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_limit,
            'page[limit]', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $way,
            'way', // param base name
            'SortWay', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_group_id,
            'contact_group_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_field,
            'search[field]', // param base name
            'StoplistSearchField', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_operator,
            'search[operator]', // param base name
            'SearchOperator', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_value,
            'search[value]', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_fields_0_field,
            'search_fields[0][field]', // param base name
            'StoplistSearchField', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_fields_0_operator,
            'search_fields[0][operator]', // param base name
            'SearchOperator', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_fields_0_value,
            'search_fields[0][value]', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
